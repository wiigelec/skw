# Functional Specification: skw_executer.py

> The **SKWExecuter** module is the execution engine of the ScratchKit build system. It is the final and most critical stage, responsible for taking the ordered, executable shell scripts generated by the **SKWScripter** and running them in the correct environment to build, package, and deploy software. Its operation is guided by a profile-specific `executer.toml` configuration file.

---

## Core Responsibilities ðŸŽ¯

* **Configuration Loading**: Reads and interprets an `executer.toml` file to get all necessary paths, execution modes, repository settings, and packaging details.
* **Orchestrated Execution**: Manages the sequential execution of the generated scripts, ensuring a predictable and repeatable build pipeline.
* **Tiered Remote & Local Caching**: Checks for pre-existing packages across an ordered list of local or remote repositories to avoid redundant builds, fetching and installing from the first repository where a package is found.
* **Package Integrity Verification**: Ensures the integrity of downloaded packages by verifying their SHA256 checksums against stored metadata before installation.
* **Environment Management**: Intelligently determines whether each script should run on the host system or within an isolated chroot environment based on configuration rules.
* **Context-Aware Packaging**: Creates distributable software archives with unique, context-aware names that prevent collisions between different build stages (e.g., cross-tools vs. final system).
* **Rich Metadata Generation**: Creates detailed JSON metadata files for each package, capturing build context, timestamps, a SHA256 checksum, and a complete file manifest.
* **Package Deployment**: Publishes newly created packages and their metadata to a single, designated local or remote repository.
* **Logging and Error Handling**: Captures the complete output of every script to a dedicated log file and halts the entire build pipeline immediately if any script fails.

---

## Functional Requirements âœ…

### Initialization and Configuration

The executer must be initialized with the context of a specific **Book** and **Profile**. Upon initialization, it must locate and load the corresponding `executer.toml` file. The system must exit with an error if this configuration file is not found, or if prerequisite artifacts like `parser_output.json` or the scripter's output directory are missing. An `auto_confirm` flag can be passed during initialization to bypass any interactive prompts, such as confirming installation to the root directory.

### Primary Execution Workflow

The main `run_all` method must iterate through all generated shell scripts in alphanumeric order and execute the following sequence for each one:

1.  **Generate Package Identifier**: Determine the unique, context-aware package filename for the current script using a configurable template.
2.  **Check Caches Sequentially**: Query the configured `download_repos` list in order. For each repository, check if a metadata file for the package exists. The existence of the metadata file is the sole indicator of a cached package.
3.  **Install or Build**:
    * **If Cached**: Download the package and its metadata from the repository where it was found. **Verify the package's SHA256 checksum** against the checksum in the metadata file. If valid, install the package, log the skip, and proceed to the next script. If the checksum fails, the build must halt.
    * **If Not Cached**: Execute the build script from source in the appropriate environment (`host` or `chroot`).
4.  **Handle Failure**: If the script returns a non-zero exit code, the executer must immediately stop the entire build process and report the failure.
5.  **Package, Install, and Deploy**: If the build was successful and the script is configured to be packaged:
    * Create a compressed tarball from the build artifacts (`DESTDIR`).
    * Generate a companion `.meta.json` file containing detailed build information and the package's SHA256 checksum.
    * Install the software from the newly created local archive.
    * Upload both the package and its metadata file to the configured `upload_repo`.

### Package Repository Management

The system must support a tiered, multi-repository system for downloads and a single repository for uploads:

* **`download_repos`**: An ordered list of sources for checking for and fetching pre-built packages. It must support:
    * **Local Filesystem Paths**: For local or network-mounted caches.
    * **HTTP(S) URLs**: For read-only remote repositories.
* **`upload_repo`**: A single destination for publishing newly created packages and their metadata. It must support:
    * **Local Filesystem Paths**.
    * **SCP Targets**: For uploading to remote servers (e.g., `user@host:/path/`).

### Context-Aware Package Naming

To prevent ambiguity and support multi-stage builds of the same software (e.g., GCC Pass 1 vs. Final), the package filename must be generated from a configurable `package_name_template` in `executer.toml`. This template must support placeholders for metadata like `{book}`, `{profile}`, `{package_name}`, and `{chapter_id}`.

### Metadata and Package Integrity

For every package created, the system must generate a corresponding `.meta.json` file. This file is the "source of truth" for a package's existence and integrity. It must contain:

* Package name, version, book, profile, chapter, and section IDs.
* Build environment details (execution mode, OS, architecture, hostname).
* A UTC timestamp of the build date.
* The size of the archive.
* **A SHA256 checksum of the package archive.**
* A complete manifest listing all file paths contained within the package.
